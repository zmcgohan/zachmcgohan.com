#!/srv/www/mysite/venv/bin/python

"""
Manager for my personal blogging system. Has multiple options to make posting and updating blog posts easy.

Options:
    create <post-name>: creates a new folder hierarchy for the new post post-name
    status: prints information on any new or updated posts
    commit <post-name>: commits a post to the database if it is new or changed, as well as moves its files to the static folder of the site
    hide <post-name>: hides a post from being displayed on any blog index page
    show <post-name>: makes a hidden post visible on index pages

NOTE: This isn't made to be a very reusable module at all, hence why everything's in one file. If I extend it at some point I might split the program into a multiple-file, smaller separate module structure but.... for right now I'll just do my best to comment it well.
"""

from mysite.blog.config import DB_FILE, BLOG_FOLDER_PATH, STATIC_BLOG_FOLDER_PATH
from os import listdir, mkdir, walk
from os.path import isfile, join, getmtime, exists, getctime
from sys import argv
from shutil import rmtree, copytree
import sqlite3

conn = sqlite3.connect(DB_FILE)
cursor = conn.cursor()

def create_post_folder(base_folder):
    """Creates a new folder (and all sub-folders + content.html) for a new post."""
    mkdir(base_folder)
    mkdir(base_folder + "/styles")
    mkdir(base_folder + "/scripts")
    mkdir(base_folder + "/images")
    f = open(base_folder + "/content.html", 'w')
    f.close()
    print "{} created.".format(base_folder)

def print_status():
    """Prints a list of any new or modified posts."""
    # get names of post folders
    blog_folders = (f for f in listdir(posts_folder) if not isfile(join(posts_folder, f)))

    # get posts in DB
    db_posts = cursor.execute("SELECT * FROM posts").fetchall()

    # put new/modified posts in lists
    new_posts = []
    modified_posts = [] # posts as first element of tuple, modified files as second element in a list
    for folder in blog_folders:
        last_modified = 0
        # if it's new, it won't be in db_posts -- last_modified will be 0, staying false
        for db_post in db_posts:
            if db_post[1] == folder:
                last_modified = db_post[3]
                break
        if last_modified: # it's a previous post -- could be unchanged or modified
            modified_files = []
            # find modified files
            for (dirpath, _, filenames) in walk(join(posts_folder, folder)):
                for filename in filenames:
                    if int(getmtime(dirpath + '/' + filename)) > last_modified:
                        modified_files.append(filename)
            if modified_files:
                modified_posts.append((folder, modified_files))
        else: # it's new!
            new_posts.append(folder)

    # print new/modified posts
    if new_posts:
        print "New posts:"
        for post in new_posts:
            print '\t{}'.format(post)
    if modified_posts:
        if new_posts: print
        print "Modified posts:"
        for post in modified_posts:
            print '\t{} ({})'.format(post[0], ', '.join(post[1]))
    if not new_posts and not modified_posts:
        print "All posts are up-to-date."

def commit_post(string_identifier):
    """Commits a post to the database and moves its styles, images and scripts from the temporary folder to static if it is updated or new."""
    if not exists(join(posts_folder, string_identifier)):
        print "ERROR: {} is not an existing post folder".format(string_identifier)
        exit(0)
    # get tuple containing creation time and last modified time if exists
    last_times = cursor.execute("SELECT time_created, last_modified FROM posts WHERE string_identifier=?", (string_identifier,)).fetchone()
    # get last modified time of all files in post folder
    last_modified = 0
    for (dirpath, _, filenames) in walk(join(posts_folder, string_identifier)):
        for filename in filenames:
            modified_time = int(getmtime(dirpath + '/' + filename))
            if modified_time > last_modified:
                last_modified = modified_time
    # set up database field values to be committed to the database
    content_file = open(join(posts_folder, string_identifier, "content.html"))
    title = content_file.readline()[:-1]
    image = content_file.readline()[:-1]
    content = content_file.read()[:-1]
    content_file.close()
    styles = ';'.join([style for style in listdir(join(posts_folder, string_identifier, "styles")) if style[-4:] == ".css"])
    scripts = ';'.join([script for script in listdir(join(posts_folder, string_identifier, "scripts")) if script[-3:] == ".js"])
    if last_times is None: # it's a new post -- INSERT it
        # create new entry into DB
        time_created = int(getctime(join(posts_folder, string_identifier)))
        try:
            move_to_static(string_identifier)
            cursor.execute("INSERT INTO posts (string_identifier, time_created, last_modified, title, image, content, styles, scripts, visible) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)", (string_identifier, time_created, last_modified, title, image, content, styles, scripts, 1))
            conn.commit()
        except Exception as e:
            print "Error inserting post '{}' into database: {}".format(string_identifier, str(e))
        else:
            print "Inserted new post '{}' into database.".format(string_identifier)
    else: # it's an old post -- UPDATE it if it has been modified
        # update entry in DB
        if last_times[1] != last_modified: # only UPDATE if last_modified isn't the same as its database last_modified
            try:
                move_to_static(string_identifier)
                cursor.execute("UPDATE posts SET last_modified=?, title=?, image=?, content=?, styles=?, scripts=? WHERE string_identifier=?", (last_modified, title, image, content, styles, scripts, string_identifier))
                conn.commit()
            except Exception as e:
                print "Error updating post '{}': {}".format(string_identifier, str(e))
            else:
                print "Updated post '{}' in database.".format(string_identifier)
        else:
            print "'{}' has not been modified since its last commit.".format(string_identifier)

def hide_post(string_identifier):
    """Hides a post from index pages."""
    if not post_exists(string_identifier):
        print "Post '{}' does not exist.".format(string_identifier)
        exit(1)
    try:
        cursor.execute("UPDATE posts SET visible=? WHERE string_identifier=?", (0, string_identifier))
        conn.commit()
    except Exception as e:
        print "Error while hiding post '{}': {}".format(string_identifier, str(e))
    else:
        print "Post '{}' has been successfully hidden.".format(string_identifier)

def show_post(string_identifier):
    """Sets a post to be visible in index pages."""
    if not post_exists(string_identifier):
        print "Post '{}' does not exist.".format(string_identifier)
        exit(1)
    try:
        cursor.execute("UPDATE posts SET visible=? WHERE string_identifier=?", (1, string_identifier))
        conn.commit()
    except Exception as e:
        print "Error while setting post '{}' to be visible: {}".format(string_identifier, str(e))
    else:
        print "Post '{}' has been made visible.".format(string_identifier)

def move_to_static(string_identifier):
    """Moves a post's subdirectories (images, scripts and styles) from the temporary section of the website's files to the website's static folder.

    NOTE: Deletes entire static folder if it exists and moves all files back over every time. Not the most efficient method by any regard."""
    new_dir = join(STATIC_BLOG_FOLDER_PATH, string_identifier)
    temp_dir = join(BLOG_FOLDER_PATH, "posts", string_identifier)
    if exists(new_dir): # remove folder recursively if it exists
        rmtree(new_dir)
    # copy over files
    copytree(join(temp_dir, "styles"), join(new_dir, "styles"))
    copytree(join(temp_dir, "scripts"), join(new_dir, "scripts"))
    copytree(join(temp_dir, "images"), join(new_dir, "images"))

def post_exists(string_identifier):
    """Returns True if a post is in the database."""
    return cursor.execute("SELECT 1 FROM posts WHERE string_identifier=?", (string_identifier,)).fetchone() is not None

def print_options():
    """Prints the program usage options."""
    print "Blog manager options:"
    print "\tcreate <post-name>: creates a new folder hierarchy for the new post <post-name>"
    print "\tstatus: prints information on any new or updated posts"
    print "\tcommit <post-name>: commits <post-name> to the database if it is new or changed, as well as moves its files to the static folder of the site"
    print "\thide <post-name>: hides a post from being displayed on any blog index page"
    print "\tshow <post-name>: makes a hidden post visible on index pages"

def verify_num_args(num_args, error_str):
    """Verifies that len(argv) == num_args; if not, show error_str and quit."""
    if len(argv) != num_args:
        print error_str
        exit(1)

if __name__ == '__main__':
    posts_folder = "{}/posts".format(BLOG_FOLDER_PATH)
    if len(argv) == 1:
        print_options()
    elif argv[1] == "create":
        verify_num_args(3, "Syntax must be: blog_manager create <post_folder_name>")
        create_post_folder(posts_folder + '/' + argv[2])
    elif argv[1] == "status":
        print_status()
    elif argv[1] == "commit":
        verify_num_args(3, "Syntax must be: blog_manager commit <post_folder_name>")
        commit_post(argv[2])
    elif argv[1] == "hide":
        verify_num_args(3, "Syntax must be: blog_manager hide <post_folder_name>")
        hide_post(argv[2])
    elif argv[1] == "show":
        verify_num_args(3, "Syntax must be: blog_manager show <post_folder_name>")
        show_post(argv[2])
    else:
        print_options()
